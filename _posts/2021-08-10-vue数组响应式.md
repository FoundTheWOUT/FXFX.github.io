---
title: 有关于vue数组响应式的记录
date: 2021-08-10
update: 2021-08-10
tag:
  - vue
image: https://source.unsplash.com/random
---

## 前言

最近在做的一个项目中的筛选模块，首先该模块的筛选输入可能会需要考虑到至少深度为两层的树。比如

```json
root [
  // 第0层，也就是所有可以筛选的项
  {
    key:foo,
    // 第1层，奴属于该项的所有“可选项”或者“选项”
    child:[
      {
        key:foo1,
        // 第二层，该项“选项”
        child:[{}]
      },
      { key:foo2 }
    ]
  }
]
```
最终觉得使用[treeMeta](https://treemate.vercel.app/)生成`treemate`然后再用其方法进行`checked`和`unchecked`操纵。

但是，在所有选项中，有些许选项它并不是一开就有的，也就是说，选项也许需要从后端获得，这时候就涉及到以下问题。

1. 如何更新选项
2. 由于`treemate`树是通过`props`生成，当`props`更新时，是否需要重新生成
3. 如果更新了，试图是否会更新

首先解决第一个问题，初步方案是获得每一层的索引（拍扁整个树），如果需要更新，依据索引进行更新。

第二个问题答案是肯定的，假如我每次更新`props`（从远端或者其它地方获取选项）都要生成一次`treemate`，这也太消耗性能了，我们可以借用筛选组件的一个特性，那就是当筛选项展开时才去生成`treemate`。

所以整个筛选组件的生命周期大概是这样的。

拿到半完整的数据生成所有可选项 -> 异步获取每个可选项的内容 -> 当可选项展开，根据完整数据生成`treemate`

这也就避免了每次更新`props`都要再生成`treemate`的问题。

最后一个问题就涉及到Vue的响应式原理了。

根据[Vue文档](https://vuejs.org/v2/guide/reactivity.html#For-Arrays)，直接修改数组里的某个值，是不会触发视图更新的。想要触发更新，需要使用`$set`或者是修改数组的方法。

可是，仔细想想，这里真的需要让视图知道我更新了吗，根据问题2的描述，一般情况下，整个筛选组件是折叠起来的（只显示每个可选项，而不显示可选项的内容），那当我去更新`data`的时候，影响的也只是可选项的内容。~~在没有视图的情况下，我为什么要追求视图也更新呢~~重点来了，`v-show`也会触发视图的更新，也就是，我更新了`props`视图没有更新没关系，因为我要看就必须展开，展开是`v-show`控制，我一旦展开，视图是拿到更新后的数据的，问题就解决了。

关于筛选组件的就是以上的内容了，还有其它的就是如何去处理边缘情况和如何处理返回数据了。这些问题都是要看具体场景的就不展开说了。




